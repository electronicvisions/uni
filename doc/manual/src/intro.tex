\chapter{Introduction}

\section{Scope of this document}

This document provides high-level overview of the \gls{uni}.
It specifies the instruction format and execution model.
Detailed description of the implementation in software and hardware is beyond the scope.


\section{Further reading}

There is Doxygen generated documentation for source code in \file{doc/doxygen}.


\section{Basic ideas}

\Gls{uni} addresses a basic problem for real-time neuromorphic hardware systems:
Stimulus such as spikes and often also configuration data has to be delivered with predictable and bounded timing.
A standard method to do this, is to store stimulation data with timing information in \gls{sdram} on an \gls{fpga} and then play it back in one go.
Result data, i.e.\ spikes generated by the hardware and responses to read requests must also be recorded with annotated timing information.
This approach allows for batch execution of experiments: load stimulus program, execute experiment, read back result data.
Further operation modes for neuromorphic hardware are continuous streaming of input stimulus and result data and recurrent communication between components of the neuromorphic hardware system.

\Gls{uni} is designed to provide all three modes of operation simultaneously in one hardware implementation.
At its core it is an instruction set definition for byte-code that defines stimulus data with timing information together with an execution model for this byte-code.
The same coding is used to encode result data.
An important characteristic of this byte-code is its independence of a particular neuromorphic hardware system (the back-end).
Instead it provides instructions for timing control, reading and writing configuration data, and for event delivery.
The back-end defines the semantics of these operations and the actual \gls{fpga} implementation of \gls{uni} performs the translation to the concrete back-end interface.

Streaming operation is enabled through double buffering: while one batch of stimulus data is being executed, the host computer transfers the next batch.
The implementation provides gap-free back-to-back execution between buffer switches.
Recurrent connections provide additional events that have to be delivered with low-latency to their destination.
This is realized by mixing units that combine event streams from within the system with batch streams coming from memory.


\section{Terms and definitions}

Here are a couple of definitions for this document:

\begin{description}
    \item[Back-end]
        A particular neuromorphic hardware system that is to be controlled and stimulated.

    \item[Instruction]
        An atomic operation for execution in the back-end or timing control.

    \item[Byte-code]
        A sequence of instructions in binary form.
        Instructions are coded in one or more byte.

    \item[Program]
        The sequence of configuration accesses and spike-events with their timing information is called a program.
        The implementation executes the program, i.e.\ plays it back to the back-end using the given timing information.
        The program is a sequence of instructions and represented as byte-code.

    \item[Implementation]
        A concrete realization of the \gls{uni} specification for a particular back-end.

    \item[Execution model]
        Defines how the program in its byte-code representation is executed in a \gls{uni} implementation.

    \item[Data frame]
        Back-end specific atomic unit of data for transfer to the neuromorphic system.
\end{description}


